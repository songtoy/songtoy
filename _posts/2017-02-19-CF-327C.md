# CF 327C. Median Smoothing
### Task
Vasya最近迷上了中值平滑，对一个数列 $a_1,a_2,...,a_n$ 应用中值平滑会将其变成一个新的数列 $b_1,b_2,...,b_n$ ,并且满足以下条件：
<ul><li>$b_1=a_1,b_n=a_n$,即首尾的两个数字保持不变. </li>
<li>对所有的$1\lt i\lt n$, $b_i$ 是 $a_{i-1},a_i,a_{i+1}$ 三个数中的中位数.</li></ul>

现在保证给出的数列{$a_n$}只包含0和1，Vasya想经过若干次中值平滑后将其变为稳定的数列. (一个稳定的数列无论经过多少次中值平滑都不会改变任何一个数字).请输出将{$a_n$}变成稳定的数列所需的最少次数，如果不能请输出-1.  
$3 ≤ n ≤ 500 000$
### Solution
考虑中值平滑的性质，即把$a_i$改为$a_{i-1},a_i,a_{i+1}$三个数中的中位数.  
由于只包含0和1，要使$a_i$经过中值平滑后被修改，只有两种可能:
<ul><li>$a_{i-1}=0,a_i=1,a_{i+1}=0$ </li><li>$a_{i-1}=1,a_i=0,a_{i+1}=1$ </li></ul> 即 $a_i\ne a_{i-1}$ 并且 $a_i\ne a_{i+1}$, 此时经过一次操作后的 $b_i$将会等于$a_{i+1}$.  
同时可以证明如果两个相邻的数字相同，则这两个数字将永远稳定.  
因此只需要处理单个的0和1即可.

可是如果01交替出现怎么办, 例如:0,1,0,1,0,1.  
不要紧，经过找规律，我们发现，对于一段区间[L,R]，若满足a[L],a[R]是稳定的（L=1或者a[L-1]=a[L],R=n或者a[R]=a[R+1])，并且[L,R]内01交替出现.   
则  
第一次操作后，a[L+1]和a[R-1]将变成稳定的（不考虑特殊情况，特殊情况特判），换句话说,a[L+1]=a[L],a[R-1]=a[R].
第二次操作后，a[L+2]和a[R-2]将变成稳定的.  
......
因此对于任意数列均可以在有限次数内变为稳定的，并且$ans=min{(R-L)/2}$ (L,R满足上述条件,换句话说，[L,R]即为每段最长的01交替的连续子序列). [L,R]可以用mark[]来找，mark[]表示每个位置是否稳定.
```
static const int M = 500005;
int A[M];
bool mark[M];//每个位置是否稳定
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",&A[i]);
	for(int i=2;i<n;++i){
		mark[i]= A[i-1]==A[i+1]&&A[i-1]!=A[i];
	}
	int ans=0;
	for(int i=1;i<=n;++i){
		if(mark[i]){
			int L=i,R=i,res=0;
			while(mark[R+1])++R;
			i=R;
			while(L<=R){
				++res;
				if(res&1)A[L]=1-A[L];
				if(L<R&&res&1)A[R]=1-A[R];
				++L,--R;
			}
			if(ans<res)ans=res;
		}
	}
	printf("%d\n",ans);
	for(int i=1;i<=n;++i)printf("%d ",A[i]);
	return 0;
}
```
$By\ SongToy$